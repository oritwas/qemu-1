#######################################################################
# Target-independent parts used in system and user emulation
universal-obj-y =
universal-obj-y += util/

#######################################################################
# QObject
qobject-obj-y = qobject/ util/

universal-obj-y += $(qobject-obj-y)

#######################################################################
# QOM
qom-obj-y = qom/

universal-obj-y += $(qom-obj-y)

#######################################################################
# oslib-obj-y is code depending on the OS (win32 vs posix)
oslib-obj-y = util/

#######################################################################
# block-obj-y is code used by both qemu system emulation and qemu-img

block-obj-y += $(qobject-obj-y) $(version-obj-y)
block-obj-y += block/ util/

ifeq ($(CONFIG_VIRTIO)$(CONFIG_VIRTFS)$(CONFIG_PCI),yyy)
# Lots of the fsdev/9pcode is pulled in by vl.c via qemu_fsdev_add.
# only pull in the actual virtio-9p device if we also enabled virtio.
CONFIG_REALLY_VIRTFS=y
endif

######################################################################
# Target independent part of system emulation. The long term path is to
# suppress *all* target specific code in case of system emulation, i.e. a
# single QEMU executable should support all CPUs and machines.

common-obj-y = $(block-obj-y)
common-obj-y += qom/
common-obj-y += readline.o
common-obj-y += $(oslib-obj-y)

common-obj-$(CONFIG_WIN32) += version.o

common-obj-y += sysemu/
common-obj-y += exec/
common-obj-y += hw/

######################################################################
# libuser

user-obj-y = user/ util/
user-obj-y += $(trace-obj-y)
user-obj-y += qom/ exec/

######################################################################
# libhw

hw-obj-y = sysemu/ hw/

######################################################################
# libdis
# NOTE: the disassembler code is only needed for debugging

libdis-y = disass/

######################################################################
# trace

ifeq ($(TRACE_BACKEND),dtrace)
TRACE_H_EXTRA_DEPS=trace-dtrace.h
endif
trace.h: trace.h-timestamp $(TRACE_H_EXTRA_DEPS)
trace.h-timestamp: $(SRC_PATH)/trace-events $(BUILD_DIR)/config-host.mak
	$(call quiet-command,$(TRACETOOL) \
		--format=h \
		--backend=$(TRACE_BACKEND) \
		< $< > $@,"  GEN   trace.h")
	@cmp -s $@ trace.h || cp $@ trace.h

trace.c: trace.c-timestamp
trace.c-timestamp: $(SRC_PATH)/trace-events $(BUILD_DIR)/config-host.mak
	$(call quiet-command,$(TRACETOOL) \
		--format=c \
		--backend=$(TRACE_BACKEND) \
		< $< > $@,"  GEN   trace.c")
	@cmp -s $@ trace.c || cp $@ trace.c

trace.o: trace.c $(GENERATED_HEADERS)

trace-dtrace.h: trace-dtrace.dtrace
	$(call quiet-command,dtrace -o $@ -h -s $<, "  GEN   trace-dtrace.h")

# Normal practice is to name DTrace probe file with a '.d' extension
# but that gets picked up by QEMU's Makefile as an external dependency
# rule file. So we use '.dtrace' instead
trace-dtrace.dtrace: trace-dtrace.dtrace-timestamp
trace-dtrace.dtrace-timestamp: $(SRC_PATH)/trace-events $(BUILD_DIR)/config-host.mak
	$(call quiet-command,$(TRACETOOL) \
		--format=d \
		--backend=$(TRACE_BACKEND) \
		< $< > $@,"  GEN   trace-dtrace.dtrace")
	@cmp -s $@ trace-dtrace.dtrace || cp $@ trace-dtrace.dtrace

trace-dtrace.o: trace-dtrace.dtrace $(GENERATED_HEADERS)
	$(call quiet-command,dtrace -o $@ -G -s $<, "  GEN   trace-dtrace.o")

ifeq ($(LIBTOOL),)
trace-dtrace.lo: trace-dtrace.dtrace
	@echo "missing libtool. please install and rerun configure."; exit 1
else
trace-dtrace.lo: trace-dtrace.dtrace
	$(call quiet-command,$(LIBTOOL) --mode=compile --tag=CC dtrace -o $@ -G -s $<, "  lt GEN trace-dtrace.o")
endif

trace/simple.o: trace/simple.c $(GENERATED_HEADERS)

trace-obj-$(CONFIG_TRACE_DTRACE) += trace-dtrace.o
ifneq ($(TRACE_BACKEND),dtrace)
trace-obj-y = trace.o
endif

trace-obj-$(CONFIG_TRACE_DEFAULT) += trace/default.o
trace-obj-$(CONFIG_TRACE_SIMPLE) += trace/simple.o
trace-obj-$(CONFIG_TRACE_SIMPLE) += util/clock.o
trace-obj-$(CONFIG_TRACE_STDERR) += trace/stderr.o
trace-obj-y += trace/control.o

$(trace-obj-y): $(GENERATED_HEADERS)

######################################################################
# smartcard

libcacard-y += libcacard/cac.o libcacard/event.o
libcacard-y += libcacard/vcard.o libcacard/vreader.o
libcacard-y += libcacard/vcard_emul_nss.o
libcacard-y += libcacard/vcard_emul_type.o
libcacard-y += libcacard/card_7816.o

common-obj-$(CONFIG_SMARTCARD_NSS) += $(libcacard-y)

######################################################################
# qapi

qapi-obj-y = qapi/
qapi-obj-y += qapi-types.o qapi-visit.o

common-obj-y += qmp-marshal.o qapi-visit.o qapi-types.o
common-obj-y += qmp.o hmp.o

universal-obj-y += $(qapi-obj-y)

######################################################################
# tools-obj-y is shared by qemu-img, qemu-io, qemu-nbd

tools-obj-y += $(oslib-obj-y) $(trace-obj-y)
tools-obj-y += qapi/ tools/ util/

######################################################################
# guest agent

qga-obj-y = qga/ util/ qapi/ $(oslib-obj-y)

vl.o: QEMU_CFLAGS+=$(GPROF_CFLAGS)

vl.o: QEMU_CFLAGS+=$(SDL_CFLAGS)

QEMU_CFLAGS+=$(GLIB_CFLAGS)

nested-vars += \
	hw-obj-y \
	oslib-obj-y \
	qobject-obj-y \
	qga-obj-y \
	block-obj-y \
	qom-obj-y \
	qapi-obj-y \
	universal-obj-y \
	user-obj-y \
	common-obj-y \
	libdis-y \
	tools-obj-y \
	extra-obj-y
dummy := $(call unnest-vars)
